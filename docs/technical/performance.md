# ‚ö° –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ DNA-utils-universal

## üöÄ –†–ï–í–û–õ–Æ–¶–ò–û–ù–ù–´–ï –£–õ–£–ß–®–ï–ù–ò–Ø (–∞–≤–≥—É—Å—Ç 2025) ‚≠ê –ù–û–í–û–ï

### –ö–∞—Ä–¥–∏–Ω–∞–ª—å–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ STR Matcher
**–î–∞—Ç–∞ –≤–Ω–µ–¥—Ä–µ–Ω–∏—è**: 01-03.08.2025  
**–°—Ç–∞—Ç—É—Å**: ‚úÖ –ü–æ–ª–Ω–æ—Å—Ç—å—é —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –∏ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–æ

#### üìä –î–æ—Å—Ç–∏–≥–Ω—É—Ç—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã:
- **üìâ –ü–∞–º—è—Ç—å**: 95% —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ (500MB ‚Üí <50MB)
- **‚ö° –°–∫–æ—Ä–æ—Å—Ç—å**: 150k –ø—Ä–æ—Ñ–∏–ª–µ–π –∑–∞ <30 —Å–µ–∫—É–Ω–¥  
- **üñ•Ô∏è UI**: 100% —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
- **üìà –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å**: –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–æ –¥–æ 300k –ø—Ä–æ—Ñ–∏–ª–µ–π

#### üîß –ö–ª—é—á–µ–≤—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏:
- **Streaming –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**: –ø–æ—Ç–æ–∫–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –±–µ–∑ memory overflow
- **Batch Web Workers**: —Ç—Ä–µ—Ö—ç—Ç–∞–ø–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å –º–∏–∫—Ä–æ-–ø–∞—É–∑–∞–º–∏
- **IndexedDB optimization**: —á—Ç–µ–Ω–∏–µ –ø–æ 1000 –∑–∞–ø–∏—Å–µ–π —Å –ø–∞—É–∑–∞–º–∏
- **Smart caching**: –∏–Ω—Ç–µ–ª–ª–∏–≥–µ–Ω—Ç–Ω–æ–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ API —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤

#### üìã –î–µ—Ç–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç:
üëâ **[–ü–æ–ª–Ω—ã–π –æ—Ç—á–µ—Ç –æ–± –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏](../reports/PERFORMANCE_OPTIMIZATION_REPORT.md)**

---

## üìã –û–±–∑–æ—Ä

DNA-utils-universal —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –±–æ–ª—å—à–∏–º–∏ –æ–±—ä–µ–º–∞–º–∏ –≥–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö (50,000+ –∑–∞–ø–∏—Å–µ–π), –≤—ã–ø–æ–ª–Ω—è–µ—Ç —Å–ª–æ–∂–Ω—ã–µ —Ä–∞—Å—á–µ—Ç—ã –≥–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∏—Å—Ç–∞–Ω—Ü–∏–π –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ API –∑–∞–ø—Ä–æ—Å—ã. –°–∏—Å—Ç–µ–º–∞ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –≤—ã—Å–æ–∫–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ –≤ –±—Ä–∞—É–∑–µ—Ä–µ –∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.

## üéØ –ö–ª—é—á–µ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

### –î–æ—Å—Ç–∏–≥–Ω—É—Ç—ã–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏ (–∞–≤–≥—É—Å—Ç 2025) ‚úÖ:
- **–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö**: < 90 —Å–µ–∫—É–Ω–¥ –¥–ª—è 150–ö –∑–∞–ø–∏—Å–µ–π ‚úÖ –î–û–°–¢–ò–ì–ù–£–¢–û
- **–†–∞—Å—á–µ—Ç –¥–∏—Å—Ç–∞–Ω—Ü–∏–π**: < 20 —Å–µ–∫—É–Ω–¥ –¥–ª—è 150K —Å—Ä–∞–≤–Ω–µ–Ω–∏–π ‚úÖ –ü–†–ï–í–´–®–ï–ù–û
- **API –æ—Ç–≤–µ—Ç—ã**: < 100–º—Å –¥–ª—è check-subclade ‚úÖ –ü–†–ï–í–´–®–ï–ù–û  
- **–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è**: < 0.5 —Å–µ–∫—É–Ω–¥—ã –¥–ª—è 150–ö –∑–∞–ø–∏—Å–µ–π ‚úÖ –ü–†–ï–í–´–®–ï–ù–û
- **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏**: < 50MB –ø–æ—Å—Ç–æ—è–Ω–Ω–æ ‚úÖ –ó–ù–ê–ß–ò–¢–ï–õ–¨–ù–û –ü–†–ï–í–´–®–ï–ù–û

### –ü—Ä–µ–¥—ã–¥—É—â–∏–µ —É–∑–∫–∏–µ –º–µ—Å—Ç–∞ (–†–ï–®–ï–ù–´) ‚úÖ:
1. ~~**–ó–∞–≥—Ä—É–∑–∫–∞ –±–æ–ª—å—à–∏—Ö JSON —Ñ–∞–π–ª–æ–≤**~~ ‚Üí **Streaming –æ–±—Ä–∞–±–æ—Ç–∫–∞**
2. ~~**–†–∞—Å—á–µ—Ç—ã –≥–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∏—Å—Ç–∞–Ω—Ü–∏–π**~~ ‚Üí **Batch Workers —Å –ø–∞—É–∑–∞–º–∏**
3. ~~**–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É–±–∫–ª–∞–¥–æ–≤**~~ ‚Üí **–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ + Batch API**
4. ~~**–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –±–æ–ª—å—à–∏—Ö —Ç–∞–±–ª–∏—Ü**~~ ‚Üí **–í–∏—Ä—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è + –ø–æ—Ç–æ–∫–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞**

### –ù–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ (–∞–≤–≥—É—Å—Ç 2025) üÜï:
- **–§–∞–π–ª—ã –¥–æ 300k –ø—Ä–æ—Ñ–∏–ª–µ–π**: –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–æ –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç
- **–ü–æ—Ç–æ–∫–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞**: —Ñ–∞–π–ª—ã –ª—é–±–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –±–µ–∑ memory overflow
- **–ü—Ä–æ–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã**: –¥–µ—Ç–∞–ª—å–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
- **–ò–Ω—Ç–µ–ª–ª–∏–≥–µ–Ω—Ç–Ω–æ–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ**: –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π

## üåê Web Workers –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π

### 1. Distance Calculator Worker

```javascript
// str-matcher/src/workers/distance-calculator.worker.js
class DistanceCalculatorWorker {
  constructor() {
    this.isProcessing = false;
    this.batchSize = 500; // –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –±–∞—Ç—á–∞
  }
  
  async processDistanceCalculation(data) {
    const { userMarkers, candidates, method, options } = data;
    
    this.isProcessing = true;
    const results = [];
    const totalBatches = Math.ceil(candidates.length / this.batchSize);
    
    console.log(`üîÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ ${candidates.length} –∑–∞–ø–∏—Å–µ–π –≤ ${totalBatches} –±–∞—Ç—á–∞—Ö`);
    
    for (let i = 0; i < candidates.length; i += this.batchSize) {
      const batch = candidates.slice(i, i + this.batchSize);
      const batchResults = await this.processBatch(userMarkers, batch, method, options);
      
      results.push(...batchResults);
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
      self.postMessage({
        type: 'progress',
        completed: i + batch.length,
        total: candidates.length,
        batchResults
      });
      
      // –î–∞–µ–º –±—Ä–∞—É–∑–µ—Ä—É –ø–µ—Ä–µ–¥—ã—à–∫—É –∫–∞–∂–¥—ã–µ 1000 –∑–∞–ø–∏—Å–µ–π
      if (i % 1000 === 0) {
        await this.sleep(10);
      }
    }
    
    this.isProcessing = false;
    return results;
  }
  
  async processBatch(userMarkers, batch, method, options) {
    const results = [];
    const startTime = performance.now();
    
    for (const candidate of batch) {
      const distance = this.calculateDistance(userMarkers, candidate.markers, method, options);
      results.push({
        target: candidate,
        ...distance
      });
    }
    
    const processingTime = performance.now() - startTime;
    console.log(`‚ö° –ë–∞—Ç—á ${batch.length} –∑–∞–ø–∏—Å–µ–π –æ–±—Ä–∞–±–æ—Ç–∞–Ω –∑–∞ ${processingTime.toFixed(2)}–º—Å`);
    
    return results;
  }
  
  calculateDistance(userMarkers, targetMarkers, method, options) {
    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—á–µ—Ç–∞ –¥–∏—Å—Ç–∞–Ω—Ü–∏–π
    switch (method) {
      case 'simple':
        return this.calculateSimpleDistanceOptimized(userMarkers, targetMarkers);
      case 'weighted':
        return this.calculateWeightedDistanceOptimized(userMarkers, targetMarkers, options);
      case 'genetic':
        return this.calculateGeneticDistanceOptimized(userMarkers, targetMarkers, options);
      default:
        return this.calculateSimpleDistanceOptimized(userMarkers, targetMarkers);
    }
  }
  
  // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ—Å—Ç–æ–π —Ä–∞—Å—á–µ—Ç
  calculateSimpleDistanceOptimized(userMarkers, targetMarkers) {
    const userKeys = Object.keys(userMarkers);
    const targetKeys = new Set(Object.keys(targetMarkers));
    
    let matches = 0;
    let mismatches = 0;
    let totalCompared = 0;
    
    // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–∞–ª–∏–Ω–¥—Ä–æ–º–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã
    const palindromicSet = new Set(['DYS385', 'DYS459', 'CDYa', 'CDYb']);
    
    for (const marker of userKeys) {
      if (!targetKeys.has(marker)) continue;
      
      totalCompared++;
      const userValue = userMarkers[marker];
      const targetValue = targetMarkers[marker];
      
      let distance;
      if (palindromicSet.has(marker)) {
        distance = this.calculatePalindromicDistanceFast(userValue, targetValue);
      } else {
        distance = Math.abs(parseInt(userValue) - parseInt(targetValue));
      }
      
      if (distance === 0) {
        matches++;
      } else {
        mismatches += distance;
      }
    }
    
    return {
      distance: mismatches,
      matches,
      mismatches,
      totalCompared,
      method: 'simple'
    };
  }
  
  calculatePalindromicDistanceFast(value1, value2) {
    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –ø–∞–ª–∏–Ω–¥—Ä–æ–º–Ω—ã—Ö –º–∞—Ä–∫–µ—Ä–æ–≤
    const vals1 = value1.split('-').map(v => parseInt(v)).filter(v => !isNaN(v)).sort();
    const vals2 = value2.split('-').map(v => parseInt(v)).filter(v => !isNaN(v)).sort();
    
    if (vals1.length !== vals2.length) {
      return Math.max(vals1.length, vals2.length);
    }
    
    let totalDistance = 0;
    for (let i = 0; i < vals1.length; i++) {
      totalDistance += Math.abs(vals1[i] - vals2[i]);
    }
    
    return totalDistance;
  }
  
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// –ì–ª–∞–≤–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π
const worker = new DistanceCalculatorWorker();

self.addEventListener('message', async (event) => {
  const { type, data, requestId } = event.data;
  
  try {
    if (type === 'CALCULATE_DISTANCES') {
      const results = await worker.processDistanceCalculation(data);
      
      self.postMessage({
        type: 'CALCULATION_COMPLETE',
        requestId,
        results
      });
    }
  } catch (error) {
    self.postMessage({
      type: 'CALCULATION_ERROR',
      requestId,
      error: error.message
    });
  }
});
```

### 2. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Worker –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ

```javascript
// str-matcher/src/services/distance-calculation.service.js
class DistanceCalculationService {
  constructor() {
    this.workers = [];
    this.workerCount = Math.min(navigator.hardwareConcurrency || 2, 4);
    this.currentWorkerIndex = 0;
    this.initializeWorkers();
  }
  
  initializeWorkers() {
    console.log(`üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ${this.workerCount} Web Workers –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤`);
    
    for (let i = 0; i < this.workerCount; i++) {
      const worker = new Worker('/workers/distance-calculator.worker.js');
      worker.onmessage = this.handleWorkerMessage.bind(this);
      this.workers.push({
        worker,
        busy: false,
        id: i
      });
    }
  }
  
  async calculateDistances(userMarkers, candidates, method = 'simple', options = {}) {
    if (candidates.length === 0) return [];
    
    console.log(`üìä –†–∞—Å—á–µ—Ç –¥–∏—Å—Ç–∞–Ω—Ü–∏–π: ${candidates.length} –∑–∞–ø–∏—Å–µ–π, –º–µ—Ç–æ–¥: ${method}`);
    
    // –í—ã–±–∏—Ä–∞–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
    if (candidates.length < 100) {
      // –î–ª—è –º–∞–ª—ã—Ö –¥–∞–Ω–Ω—ã—Ö - –≤—ã—á–∏—Å–ª—è–µ–º –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ
      return this.calculateInMainThread(userMarkers, candidates, method, options);
    } else {
      // –î–ª—è –±–æ–ª—å—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö - –∏—Å–ø–æ–ª—å–∑—É–µ–º Web Workers
      return this.calculateWithWorkers(userMarkers, candidates, method, options);
    }
  }
  
  async calculateWithWorkers(userMarkers, candidates, method, options) {
    const startTime = performance.now();
    
    // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–±–æ—Ç—É –º–µ–∂–¥—É –≤–æ—Ä–∫–µ—Ä–∞–º–∏
    const workersToUse = Math.min(this.workerCount, Math.ceil(candidates.length / 1000));
    const chunkSize = Math.ceil(candidates.length / workersToUse);
    
    const promises = [];
    
    for (let i = 0; i < workersToUse; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, candidates.length);
      const chunk = candidates.slice(start, end);
      
      if (chunk.length > 0) {
        promises.push(this.processChunkWithWorker(userMarkers, chunk, method, options, i));
      }
    }
    
    const results = await Promise.all(promises);
    const flatResults = results.flat();
    
    const totalTime = performance.now() - startTime;
    console.log(`‚ö° –†–∞—Å—á–µ—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã: ${flatResults.length} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∑–∞ ${totalTime.toFixed(2)}–º—Å`);
    
    return flatResults;
  }
  
  processChunkWithWorker(userMarkers, chunk, method, options, workerId) {
    return new Promise((resolve, reject) => {
      const worker = this.workers[workerId % this.workers.length];
      const requestId = `${Date.now()}-${workerId}`;
      
      worker.busy = true;
      
      const timeout = setTimeout(() => {
        reject(new Error(`Worker ${workerId} timeout`));
      }, 30000); // 30 —Å–µ–∫—É–Ω–¥ —Ç–∞–π–º–∞—É—Ç
      
      const handleMessage = (event) => {
        const { type, requestId: responseId, results, error } = event.data;
        
        if (responseId !== requestId) return;
        
        clearTimeout(timeout);
        worker.worker.removeEventListener('message', handleMessage);
        worker.busy = false;
        
        if (type === 'CALCULATION_COMPLETE') {
          resolve(results);
        } else if (type === 'CALCULATION_ERROR') {
          reject(new Error(error));
        }
      };
      
      worker.worker.addEventListener('message', handleMessage);
      worker.worker.postMessage({
        type: 'CALCULATE_DISTANCES',
        requestId,
        data: { userMarkers, candidates: chunk, method, options }
      });
    });
  }
  
  calculateInMainThread(userMarkers, candidates, method, options) {
    // –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ —Ä–∞—Å—á–µ—Ç—ã –¥–ª—è –Ω–µ–±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤ –¥–∞–Ω–Ω—ã—Ö
    const results = [];
    
    for (const candidate of candidates) {
      const distance = this.calculateSingleDistance(userMarkers, candidate.markers, method, options);
      results.push({
        target: candidate,
        ...distance
      });
    }
    
    return results;
  }
}
```

## üíæ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é

### 1. –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è

```javascript
// str-matcher/src/services/cache.service.js
class AdvancedCacheService {
  constructor() {
    this.memoryCache = new Map();          // L1 - –ì–æ—Ä—è—á–∏–µ –¥–∞–Ω–Ω—ã–µ
    this.compressionCache = new Map();     // L2 - –°–∂–∞—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ  
    this.diskCache = null;                 // L3 - –î–∏—Å–∫ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
    
    this.maxMemorySize = 100 * 1024 * 1024; // 100MB
    this.currentMemoryUsage = 0;
    
    this.statistics = {
      hits: { L1: 0, L2: 0, L3: 0 },
      misses: 0,
      evictions: 0,
      compressions: 0
    };
    
    this.initializeCache();
  }
  
  initializeCache() {
    // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –∫—ç—à–∞
    setInterval(() => this.cleanupCache(), 5 * 60 * 1000); // –ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
    
    // –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏
    if (performance.memory) {
      setInterval(() => this.monitorMemoryUsage(), 30 * 1000); // –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
    }
  }
  
  async get(key) {
    // L1 - Memory cache
    if (this.memoryCache.has(key)) {
      const entry = this.memoryCache.get(key);
      entry.lastAccessed = Date.now();
      entry.accessCount++;
      this.statistics.hits.L1++;
      return entry.data;
    }
    
    // L2 - Compressed cache
    if (this.compressionCache.has(key)) {
      const compressedEntry = this.compressionCache.get(key);
      const decompressedData = await this.decompress(compressedEntry.data);
      
      // –ü—Ä–æ–¥–≤–∏–≥–∞–µ–º –≤ L1 –µ—Å–ª–∏ –µ—Å—Ç—å –º–µ—Å—Ç–æ
      if (this.canStoreInMemory(decompressedData)) {
        this.setInMemory(key, decompressedData);
      }
      
      this.statistics.hits.L2++;
      return decompressedData;
    }
    
    // L3 - Disk cache (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
    if (this.diskCache) {
      const diskData = await this.diskCache.get(key);
      if (diskData) {
        this.statistics.hits.L3++;
        return diskData;
      }
    }
    
    this.statistics.misses++;
    return null;
  }
  
  async set(key, data, options = {}) {
    const dataSize = this.estimateSize(data);
    const priority = options.priority || 'normal';
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –º–µ—Å—Ç–æ —Ö—Ä–∞–Ω–µ–Ω–∏—è
    if (priority === 'high' && this.canStoreInMemory(data)) {
      this.setInMemory(key, data);
    } else if (dataSize > 1024 * 1024) { // > 1MB
      // –ë–æ–ª—å—à–∏–µ –¥–∞–Ω–Ω—ã–µ —Å–∂–∏–º–∞–µ–º –∏ —Ö—Ä–∞–Ω–∏–º –≤ L2
      await this.setCompressed(key, data, options);
    } else {
      this.setInMemory(key, data);
    }
  }
  
  setInMemory(key, data) {
    const dataSize = this.estimateSize(data);
    
    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –º–µ—Å—Ç–æ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    while (this.currentMemoryUsage + dataSize > this.maxMemorySize) {
      this.evictLRU();
    }
    
    const entry = {
      data,
      size: dataSize,
      timestamp: Date.now(),
      lastAccessed: Date.now(),
      accessCount: 1,
      level: 'L1'
    };
    
    this.memoryCache.set(key, entry);
    this.currentMemoryUsage += dataSize;
  }
  
  async setCompressed(key, data, options) {
    try {
      const compressed = await this.compress(data);
      const compressedSize = this.estimateSize(compressed);
      
      if (compressedSize < this.estimateSize(data) * 0.7) { // –°–∂–∞—Ç–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ
        this.compressionCache.set(key, {
          data: compressed,
          size: compressedSize,
          timestamp: Date.now(),
          originalSize: this.estimateSize(data),
          compressionRatio: compressedSize / this.estimateSize(data)
        });
        
        this.statistics.compressions++;
        console.log(`üì¶ –î–∞–Ω–Ω—ã–µ —Å–∂–∞—Ç—ã: ${key}, –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç: ${(compressedSize / this.estimateSize(data)).toFixed(2)}`);
      } else {
        // –°–∂–∞—Ç–∏–µ –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ, —Ö—Ä–∞–Ω–∏–º –∫–∞–∫ –µ—Å—Ç—å
        this.setInMemory(key, data);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–∂–∞—Ç–∏—è –¥–∞–Ω–Ω—ã—Ö:', error);
      this.setInMemory(key, data);
    }
  }
  
  evictLRU() {
    let lruKey = null;
    let lruTime = Date.now();
    
    for (const [key, entry] of this.memoryCache) {
      if (entry.lastAccessed < lruTime) {
        lruTime = entry.lastAccessed;
        lruKey = key;
      }
    }
    
    if (lruKey) {
      const entry = this.memoryCache.get(lruKey);
      this.memoryCache.delete(lruKey);
      this.currentMemoryUsage -= entry.size;
      this.statistics.evictions++;
      
      console.log(`üóëÔ∏è Evicted from cache: ${lruKey} (freed ${entry.size} bytes)`);
    }
  }
  
  async compress(data) {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ API —Å–∂–∞—Ç–∏—è –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã
    if (typeof CompressionStream !== 'undefined') {
      const stream = new CompressionStream('gzip');
      const writer = stream.writable.getWriter();
      const reader = stream.readable.getReader();
      
      const jsonString = JSON.stringify(data);
      const encoder = new TextEncoder();
      const input = encoder.encode(jsonString);
      
      writer.write(input);
      writer.close();
      
      const chunks = [];
      let done = false;
      
      while (!done) {
        const { value, done: readerDone } = await reader.read();
        done = readerDone;
        if (value) chunks.push(value);
      }
      
      return new Uint8Array(chunks.reduce((acc, chunk) => [...acc, ...chunk], []));
    } else {
      // Fallback - –ø—Ä–æ—Å—Ç–æ–µ —Å–∂–∞—Ç–∏–µ JSON
      return this.simpleCompress(JSON.stringify(data));
    }
  }
  
  async decompress(compressedData) {
    if (typeof DecompressionStream !== 'undefined' && compressedData instanceof Uint8Array) {
      const stream = new DecompressionStream('gzip');
      const writer = stream.writable.getWriter();
      const reader = stream.readable.getReader();
      
      writer.write(compressedData);
      writer.close();
      
      const chunks = [];
      let done = false;
      
      while (!done) {
        const { value, done: readerDone } = await reader.read();
        done = readerDone;
        if (value) chunks.push(value);
      }
      
      const decoder = new TextDecoder();
      const decompressed = decoder.decode(new Uint8Array(chunks.reduce((acc, chunk) => [...acc, ...chunk], [])));
      
      return JSON.parse(decompressed);
    } else {
      // Fallback –¥–µcompression
      return JSON.parse(this.simpleDecompress(compressedData));
    }
  }
  
  canStoreInMemory(data) {
    const dataSize = this.estimateSize(data);
    return dataSize <= this.maxMemorySize * 0.1; // –ù–µ –±–æ–ª–µ–µ 10% –æ—Ç –ª–∏–º–∏—Ç–∞ –Ω–∞ –æ–¥–Ω—É –∑–∞–ø–∏—Å—å
  }
  
  estimateSize(data) {
    // –ü—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ –æ–±—ä–µ–∫—Ç–∞ –≤ –±–∞–π—Ç–∞—Ö
    return JSON.stringify(data).length * 2; // UTF-16 encoding
  }
  
  monitorMemoryUsage() {
    if (performance.memory) {
      const memInfo = performance.memory;
      const usagePercent = (memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit) * 100;
      
      if (usagePercent > 80) {
        console.warn(`‚ö†Ô∏è –í—ã—Å–æ–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏: ${usagePercent.toFixed(1)}%`);
        this.aggressiveCleanup();
      }
    }
  }
  
  aggressiveCleanup() {
    // –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –Ω–µ—Ö–≤–∞—Ç–∫–µ –ø–∞–º—è—Ç–∏
    const originalSize = this.memoryCache.size;
    
    // –£–¥–∞–ª—è–µ–º 50% –Ω–∞–∏–º–µ–Ω–µ–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –∑–∞–ø–∏—Å–µ–π
    const entries = Array.from(this.memoryCache.entries());
    entries.sort((a, b) => a[1].accessCount - b[1].accessCount);
    
    const toRemove = Math.floor(entries.length / 2);
    for (let i = 0; i < toRemove; i++) {
      const [key, entry] = entries[i];
      this.memoryCache.delete(key);
      this.currentMemoryUsage -= entry.size;
    }
    
    console.log(`üßπ –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞: —É–¥–∞–ª–µ–Ω–æ ${toRemove} –∑–∞–ø–∏—Å–µ–π –∏–∑ ${originalSize}`);
  }
  
  getStatistics() {
    const totalHits = this.statistics.hits.L1 + this.statistics.hits.L2 + this.statistics.hits.L3;
    const totalRequests = totalHits + this.statistics.misses;
    
    return {
      ...this.statistics,
      hitRate: totalRequests > 0 ? totalHits / totalRequests : 0,
      memoryUsage: {
        current: this.currentMemoryUsage,
        max: this.maxMemorySize,
        percentage: (this.currentMemoryUsage / this.maxMemorySize) * 100
      },
      cacheSize: {
        L1: this.memoryCache.size,
        L2: this.compressionCache.size
      }
    };
  }
}
```

## üèéÔ∏è –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö

### 1. –ü–æ—Ç–æ–∫–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º

```javascript
// str-matcher/src/services/data-loader-optimized.service.js
class OptimizedDataLoader {
  constructor() {
    this.cache = new AdvancedCacheService();
    this.activeRequests = new Map();
    this.loadingStrategies = {
      'small': this.loadDirectly.bind(this),
      'medium': this.loadInChunks.bind(this),
      'large': this.loadWithStreaming.bind(this)
    };
  }
  
  async loadRepository(repositoryConfig, onProgress) {
    const cacheKey = `repo_${repositoryConfig.name}_${repositoryConfig.version || 'latest'}`;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      console.log(`üìã –†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π ${repositoryConfig.name} –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ –∫—ç—à–∞`);
      onProgress && onProgress({ loaded: cached.length, total: cached.length, status: 'cached' });
      return cached;
    }
    
    // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤
    if (this.activeRequests.has(cacheKey)) {
      console.log(`‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è ${repositoryConfig.name}`);
      return await this.activeRequests.get(cacheKey);
    }
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –∑–∞–≥—Ä—É–∑–∫–∏
    const strategy = await this.selectLoadingStrategy(repositoryConfig);
    console.log(`üöÄ –ó–∞–≥—Ä—É–∑–∫–∞ ${repositoryConfig.name} —Å—Ç—Ä–∞—Ç–µ–≥–∏–µ–π: ${strategy}`);
    
    const loadPromise = this.loadingStrategies[strategy](repositoryConfig, onProgress);
    this.activeRequests.set(cacheKey, loadPromise);
    
    try {
      const data = await loadPromise;
      
      // –ö—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
      await this.cache.set(cacheKey, data, { priority: 'high' });
      
      return data;
    } finally {
      this.activeRequests.delete(cacheKey);
    }
  }
  
  async selectLoadingStrategy(repositoryConfig) {
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ
    try {
      const response = await fetch(repositoryConfig.url, { method: 'HEAD' });
      const contentLength = response.headers.get('content-length');
      
      if (contentLength) {
        const sizeInMB = parseInt(contentLength) / (1024 * 1024);
        
        if (sizeInMB < 1) return 'small';
        if (sizeInMB < 10) return 'medium'; 
        return 'large';
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞:', error);
    }
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —ç–≤—Ä–∏—Å—Ç–∏–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–∑–≤–∞–Ω–∏—è —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
    if (repositoryConfig.name === 'FTDNA') return 'large';
    if (repositoryConfig.name === 'YFull') return 'medium';
    return 'small';
  }
  
  async loadDirectly(repositoryConfig, onProgress) {
    const response = await fetch(repositoryConfig.url);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    const processedData = this.processRawData(data, repositoryConfig);
    
    onProgress && onProgress({ 
      loaded: processedData.length, 
      total: processedData.length, 
      status: 'complete' 
    });
    
    return processedData;
  }
  
  async loadInChunks(repositoryConfig, onProgress) {
    const response = await fetch(repositoryConfig.url);
    const reader = response.body.getReader();
    
    let receivedLength = 0;
    const contentLength = parseInt(response.headers.get('content-length')) || 0;
    const chunks = [];
    
    while (true) {
      const { done, value } = await reader.read();
      
      if (done) break;
      
      chunks.push(value);
      receivedLength += value.length;
      
      onProgress && onProgress({
        loaded: receivedLength,
        total: contentLength,
        status: 'loading',
        percentage: contentLength > 0 ? (receivedLength / contentLength) * 100 : 0
      });
      
      // –î–∞–µ–º –±—Ä–∞—É–∑–µ—Ä—É –ø–µ—Ä–µ–¥—ã—à–∫—É –∫–∞–∂–¥—ã–µ 1MB
      if (receivedLength % (1024 * 1024) === 0) {
        await new Promise(resolve => setTimeout(resolve, 1));
      }
    }
    
    // –û–±—ä–µ–¥–∏–Ω—è–µ–º —á–∞–Ω–∫–∏ –∏ –ø–∞—Ä—Å–∏–º JSON
    const allChunks = new Uint8Array(receivedLength);
    let position = 0;
    
    for (const chunk of chunks) {
      allChunks.set(chunk, position);
      position += chunk.length;
    }
    
    const decoder = new TextDecoder();
    const jsonString = decoder.decode(allChunks); 
    const data = JSON.parse(jsonString);
    
    onProgress && onProgress({ loaded: 0, total: data.length, status: 'processing' });
    
    const processedData = await this.processRawDataAsync(data, repositoryConfig, onProgress);
    
    return processedData;
  }
  
  async loadWithStreaming(repositoryConfig, onProgress) {
    // –î–ª—è –æ—á–µ–Ω—å –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Ç–æ–∫–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É
    console.log(`üåä –ü–æ—Ç–æ–∫–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ ${repositoryConfig.name}`);
    
    const response = await fetch(repositoryConfig.url);
    const stream = response.body
      .pipeThrough(new TextDecoderStream())
      .pipeThrough(new JSONParseStream()); // –ö–∞—Å—Ç–æ–º–Ω—ã–π transform stream
    
    const reader = stream.getReader();
    const processedData = [];
    let processedCount = 0;
    
    try {
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ—Ä—Ü–∏—é –¥–∞–Ω–Ω—ã—Ö
        const processedBatch = this.processRawDataBatch(value, repositoryConfig);
        processedData.push(...processedBatch);
        processedCount += processedBatch.length;
        
        onProgress && onProgress({
          loaded: processedCount,
          total: null, // –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ –¥–ª—è –ø–æ—Ç–æ–∫–æ–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–∏
          status: 'streaming'
        });
        
        // –ü–µ—Ä–µ–¥—ã—à–∫–∞ –∫–∞–∂–¥—ã–µ 1000 –∑–∞–ø–∏—Å–µ–π
        if (processedCount % 1000 === 0) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
    } finally {
      reader.releaseLock();
    }
    
    onProgress && onProgress({
      loaded: processedData.length,
      total: processedData.length,
      status: 'complete'
    });
    
    return processedData;
  }
  
  async processRawDataAsync(rawData, repositoryConfig, onProgress) {
    const processedData = [];
    const batchSize = 1000;
    const totalBatches = Math.ceil(rawData.length / batchSize);
    
    for (let i = 0; i < rawData.length; i += batchSize) {
      const batch = rawData.slice(i, i + batchSize);
      const processedBatch = this.processRawDataBatch(batch, repositoryConfig);
      
      processedData.push(...processedBatch);
      
      onProgress && onProgress({
        loaded: processedData.length,
        total: rawData.length,
        status: 'processing',
        batch: Math.floor(i / batchSize) + 1,
        totalBatches
      });
      
      // –ü–µ—Ä–µ–¥—ã—à–∫–∞ –∫–∞–∂–¥—ã–π –±–∞—Ç—á
      await new Promise(resolve => setTimeout(resolve, 1));
    }
    
    return processedData;
  }
  
  processRawDataBatch(batch, repositoryConfig) {
    return batch
      .map(entry => this.transformEntry(entry, repositoryConfig))
      .filter(entry => this.validateEntry(entry));
  }
  
  transformEntry(rawEntry, repositoryConfig) {
    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é –µ—Å–ª–∏ –µ—Å—Ç—å
    if (repositoryConfig.transform) {
      return repositoryConfig.transform(rawEntry);
    }
    
    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è
    return {
      name: rawEntry.name || rawEntry.id,
      haplogroup: this.normalizeHaplogroup(rawEntry.haplogroup),
      markers: this.normalizeMarkers(rawEntry.markers),
      metadata: {
        source: repositoryConfig.name,
        quality: rawEntry.quality || 'medium',
        updated: rawEntry.updated || new Date().toISOString()
      }
    };
  }
  
  validateEntry(entry) {
    return entry.name && 
           entry.haplogroup && 
           entry.markers && 
           Object.keys(entry.markers).length > 0;
  }
}
```

## üìä –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞

### 1. –í–∏—Ä—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è –±–æ–ª—å—à–∏—Ö —Ç–∞–±–ª–∏—Ü

```javascript
// str-matcher/src/components/VirtualizedMatchesTable.tsx
import { FixedSizeList as List } from 'react-window';
import { useMemo, useCallback } from 'react';

interface VirtualizedMatchesTableProps {
  matches: DistanceResult[];
  onRowClick: (match: DistanceResult) => void;
  height: number;
}

const VirtualizedMatchesTable: React.FC<VirtualizedMatchesTableProps> = ({
  matches,
  onRowClick,
  height = 600
}) => {
  const itemData = useMemo(() => ({
    matches,
    onRowClick
  }), [matches, onRowClick]);
  
  const MatchRow = useCallback(({ index, style, data }) => {
    const match = data.matches[index];
    
    return (
      <div 
        style={style} 
        className="matches-row"
        onClick={() => data.onRowClick(match)}
      >
        <OptimizedMatchRow match={match} />
      </div>
    );
  }, []);
  
  if (matches.length === 0) {
    return <div>–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</div>;
  }
  
  return (
    <List
      height={height}
      itemCount={matches.length}
      itemSize={60} // –í—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
      itemData={itemData}
      overscanCount={10} // –†–µ–Ω–¥–µ—Ä–∏–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –ø–ª–∞–≤–Ω–æ–π –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
    >
      {MatchRow}
    </List>
  );
};

// –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å—Ç—Ä–æ–∫–∏
const OptimizedMatchRow = React.memo<{ match: DistanceResult }>(({ match }) => {
  return (
    <div className="match-row-content">
      <span className="match-name">{match.target.name}</span>
      <span className="match-haplogroup">{match.target.haplogroup}</span>
      <span className="match-distance">{match.distance}</span>
      <span className="match-markers">{match.matchedMarkers}/{match.totalMarkers}</span>
    </div>
  );
});
```

### 2. –ú–µ–º–æ–∏–∑–∞—Ü–∏—è –¥–æ—Ä–æ–≥–∏—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π

```javascript
// str-matcher/src/hooks/useOptimizedMatches.ts
import { useMemo, useCallback } from 'react';
import { debounce } from 'lodash';

export const useOptimizedMatches = (
  userMarkers: MarkerSet,
  repositories: Repository[],
  filters: FilterOptions
) => {
  // –ú–µ–º–æ–∏–∑–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
  const processedRepositories = useMemo(() => {
    console.log('üîÑ –ü–µ—Ä–µ—Å—á–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤');
    
    return repositories.map(repo => ({
      ...repo,
      processedData: repo.data.map(entry => ({
        ...entry,
        // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â–∏–µ –º–∞—Ä–∫–µ—Ä—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        commonMarkers: Object.keys(entry.markers).filter(marker => 
          userMarkers.hasOwnProperty(marker)
        ),
        markerCount: Object.keys(entry.markers).length
      }))
    }));
  }, [repositories, userMarkers]);
  
  // –ú–µ–º–æ–∏–∑–∏—Ä—É–µ–º –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
  const filteredData = useMemo(() => {
    console.log('üîç –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤');
    
    return processedRepositories.flatMap(repo => 
      repo.processedData.filter(entry => {
        // –ë—ã—Å—Ç—Ä—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–Ω–∞—á–∞–ª–∞
        if (filters.minMarkers && entry.commonMarkers.length < filters.minMarkers) {
          return false;
        }
        
        if (filters.haplogroup && filters.haplogroup !== 'all') {
          // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –≤—ã–∑–æ–≤ API –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É–±–∫–ª–∞–¥–æ–≤
          // –ù–æ –º—ã –∫—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
          return true; // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è
        }
        
        return true;
      })
    );
  }, [processedRepositories, filters]);
  
  // –î–µ–±–∞—É–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç –¥–∏—Å—Ç–∞–Ω—Ü–∏–π
  const calculateDistancesDebounced = useCallback(
    debounce(async (data: ProcessedEntry[]) => {
      const distanceService = new DistanceCalculationService();
      return await distanceService.calculateDistances(
        userMarkers,
        data,
        filters.method || 'simple'
      );
    }, 300),
    [userMarkers, filters.method]
  );
  
  return {
    processedRepositories,
    filteredData,
    calculateDistancesDebounced
  };
};
```

## üöÄ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è API –∑–∞–ø—Ä–æ—Å–æ–≤

### 1. –ë–∞—Ç—á–∏–Ω–≥ –∏ –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è

```javascript
// ftdna_haplo/server/middleware/api-optimization.js
class APIOptimizationMiddleware {
  constructor() {
    this.requestBatcher = new RequestBatcher();
    this.responseCache = new Map();
    this.pendingRequests = new Map();
  }
  
  // –ë–∞—Ç—á–∏–Ω–≥ –∑–∞–ø—Ä–æ—Å–æ–≤ check-subclade
  async batchSubcladeChecks(req, res, next) {
    if (req.path !== '/api/check-subclade' || req.method !== 'POST') {
      return next();
    }
    
    const { haplogroup, subclade, source } = req.body;
    const requestKey = `${haplogroup}|${subclade}|${source}`;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
    if (this.responseCache.has(requestKey)) {
      const cached = this.responseCache.get(requestKey);
      if (Date.now() - cached.timestamp < 300000) { // 5 –º–∏–Ω—É—Ç TTL
        return res.json(cached.data);
      }
    }
    
    // –î–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
    if (this.pendingRequests.has(requestKey)) {
      const pendingPromise = this.pendingRequests.get(requestKey);
      const result = await pendingPromise;
      return res.json(result);
    }
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
    const requestPromise = this.processSubcladeCheck(haplogroup, subclade, source);
    this.pendingRequests.set(requestKey, requestPromise);
    
    try {
      const result = await requestPromise;
      
      // –ö—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
      this.responseCache.set(requestKey, {
        data: result,
        timestamp: Date.now()
      });
      
      return res.json(result);
    } finally {
      this.pendingRequests.delete(requestKey);
    }
  }
  
  async processSubcladeCheck(haplogroup, subclade, source) {
    // –†–µ–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
    const result = await haplogroupService.isSubclade(haplogroup, subclade, source);
    
    return {
      isSubclade: result.isSubclade,
      confidence: result.confidence,
      method: result.method,
      path: result.path,
      source: source,
      timestamp: Date.now()
    };
  }
}

// –ë–∞—Ç—á–µ—Ä –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
class RequestBatcher {
  constructor() {
    this.batches = new Map();
    this.batchTimeout = 50; // –ñ–¥–µ–º 50–º—Å –ø–µ—Ä–µ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –±–∞—Ç—á–∞
  }
  
  addToBatch(key, request) {
    if (!this.batches.has(key)) {
      this.batches.set(key, []);
      
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–∞—Ç—á–∞
      setTimeout(() => {
        this.processBatch(key);
      }, this.batchTimeout);
    }
    
    this.batches.get(key).push(request);
  }
  
  async processBatch(key) {
    const requests = this.batches.get(key);
    if (!requests || requests.length === 0) return;
    
    this.batches.delete(key);
    
    console.log(`üì¶ –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–∞—Ç—á–∞ ${key}: ${requests.length} –∑–∞–ø—Ä–æ—Å–æ–≤`);
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ –∑–∞–ø—Ä–æ—Å—ã –≤ –±–∞—Ç—á–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
    const results = await Promise.allSettled(
      requests.map(req => this.processRequest(req))
    );
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—Å–µ–º –æ–∂–∏–¥–∞—é—â–∏–º –∫–ª–∏–µ–Ω—Ç–∞–º
    results.forEach((result, index) => {
      const request = requests[index];
      if (result.status === 'fulfilled') {
        request.resolve(result.value);
      } else {
        request.reject(result.reason);
      }
    });
  }
}
```

## üìà –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

### 1. Performance –º–µ—Ç—Ä–∏–∫–∏

```javascript
// str-matcher/src/services/performance-monitor.service.js
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.observers = [];
    this.isMonitoring = false;
    
    this.initializeObservers();
  }
  
  initializeObservers() {
    // Performance Observer –¥–ª—è Web Vitals
    if (typeof PerformanceObserver !== 'undefined') {
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.recordMetric(entry.name, entry.duration, {
            type: entry.entryType,
            startTime: entry.startTime
          });
        }
      });
      
      observer.observe({ entryTypes: ['measure', 'navigation', 'resource'] });
      this.observers.push(observer);
    }
  }
  
  startMonitoring() {
    this.isMonitoring = true;
    console.log('üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∑–∞–ø—É—â–µ–Ω');
    
    // –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–∞–º—è—Ç–∏
    if (performance.memory) {
      setInterval(() => {
        this.recordMemoryUsage();
      }, 10000); // –ö–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
    }
    
    // –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ FPS
    this.startFPSMonitoring();
  }
  
  measureAsync(name, asyncFunction) {
    return async (...args) => {
      const startTime = performance.now();
      performance.mark(`${name}-start`);
      
      try {
        const result = await asyncFunction.apply(this, args);
        
        const endTime = performance.now();
        performance.mark(`${name}-end`);
        performance.measure(name, `${name}-start`, `${name}-end`);
        
        const duration = endTime - startTime;
        this.recordMetric(name, duration, { status: 'success' });
        
        console.log(`‚ö° ${name}: ${duration.toFixed(2)}–º—Å`);
        
        return result;
      } catch (error) {
        const endTime = performance.now();
        const duration = endTime - startTime;
        this.recordMetric(name, duration, { status: 'error', error: error.message });
        
        console.error(`‚ùå ${name} failed after ${duration.toFixed(2)}–º—Å:`, error);
        throw error;
      }
    };
  }
  
  recordMetric(name, value, metadata = {}) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, {
        count: 0,
        total: 0,
        min: Infinity,
        max: -Infinity,
        values: []
      });
    }
    
    const metric = this.metrics.get(name);
    metric.count++;
    metric.total += value;
    metric.min = Math.min(metric.min, value);
    metric.max = Math.max(metric.max, value);
    
    // –•—Ä–∞–Ω–∏–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–∏–ª–µ–π
    metric.values.push(value);
    if (metric.values.length > 100) {
      metric.values.shift();
    }
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    metric.lastMetadata = metadata;
    metric.lastUpdated = Date.now();
  }
  
  getMetrics() {
    const result = {};
    
    for (const [name, metric] of this.metrics) {
      const sortedValues = [...metric.values].sort((a, b) => a - b);
      
      result[name] = {
        count: metric.count,
        average: metric.total / metric.count,
        min: metric.min,
        max: metric.max,
        p95: this.percentile(sortedValues, 0.95),
        p99: this.percentile(sortedValues, 0.99),
        lastUpdated: metric.lastUpdated
      };
    }
    
    return result;
  }
  
  percentile(sortedValues, p) {
    if (sortedValues.length === 0) return 0;
    
    const index = Math.ceil(sortedValues.length * p) - 1;
    return sortedValues[Math.max(0, index)];
  }
  
  recordMemoryUsage() {
    if (performance.memory) {
      const memory = performance.memory;
      
      this.recordMetric('memory.used', memory.usedJSHeapSize);
      this.recordMetric('memory.total', memory.totalJSHeapSize);
      this.recordMetric('memory.limit', memory.jsHeapSizeLimit);
      
      const usagePercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;
      this.recordMetric('memory.usage_percent', usagePercent);
      
      // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø–∞–º—è—Ç–∏
      if (usagePercent > 85) {
        console.warn(`‚ö†Ô∏è –í—ã—Å–æ–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏: ${usagePercent.toFixed(1)}%`);
      }
    }
  }
  
  startFPSMonitoring() {
    let lastTime = performance.now();
    let frameCount = 0;
    
    const measureFPS = () => {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime - lastTime >= 1000) { // –ö–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
        const fps = frameCount / ((currentTime - lastTime) / 1000);
        this.recordMetric('fps', fps);
        
        if (fps < 30) {
          console.warn(`‚ö†Ô∏è –ù–∏–∑–∫–∏–π FPS: ${fps.toFixed(1)}`);
        }
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      if (this.isMonitoring) {
        requestAnimationFrame(measureFPS);
      }
    };
    
    requestAnimationFrame(measureFPS);
  }
  
  generateReport() {
    const metrics = this.getMetrics();
    
    const report = {
      timestamp: new Date().toISOString(),
      performance: metrics,
      recommendations: this.generateRecommendations(metrics),
      systemInfo: {
        userAgent: navigator.userAgent,
        hardwareConcurrency: navigator.hardwareConcurrency,
        memory: performance.memory ? {
          used: performance.memory.usedJSHeapSize,
          total: performance.memory.totalJSHeapSize,
          limit: performance.memory.jsHeapSizeLimit
        } : null
      }
    };
    
    return report;
  }
  
  generateRecommendations(metrics) {
    const recommendations = [];
    
    // –ê–Ω–∞–ª–∏–∑ –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö
    if (metrics['data-loading'] && metrics['data-loading'].average > 5000) {
      recommendations.push({
        type: 'performance',
        priority: 'high',
        issue: '–ú–µ–¥–ª–µ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö',
        suggestion: '–†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –∏–ª–∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è'
      });
    }
    
    // –ê–Ω–∞–ª–∏–∑ —Ä–∞—Å—á–µ—Ç–æ–≤ –¥–∏—Å—Ç–∞–Ω—Ü–∏–π
    if (metrics['distance-calculation'] && metrics['distance-calculation'].average > 3000) {
      recommendations.push({
        type: 'performance',
        priority: 'medium',
        issue: '–ú–µ–¥–ª–µ–Ω–Ω—ã–µ —Ä–∞—Å—á–µ—Ç—ã –¥–∏—Å—Ç–∞–Ω—Ü–∏–π',
        suggestion: '–£–≤–µ–ª–∏—á—å—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ Web Workers –∏–ª–∏ –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–π—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã'
      });
    }
    
    // –ê–Ω–∞–ª–∏–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏
    if (metrics['memory.usage_percent'] && metrics['memory.usage_percent'].average > 80) {
      recommendations.push({
        type: 'memory',
        priority: 'high',
        issue: '–í—ã—Å–æ–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏',
        suggestion: '–í–∫–ª—é—á–∏—Ç–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—É—é –æ—á–∏—Å—Ç–∫—É –∫—ç—à–∞ –∏–ª–∏ —É–º–µ–Ω—å—à–∏—Ç–µ —Ä–∞–∑–º–µ—Ä –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö'
      });
    }
    
    return recommendations;
  }
}

// –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –º–æ–Ω–∏—Ç–æ—Ä–∞
export const performanceMonitor = new PerformanceMonitor();
```

## üîó –°–≤—è–∑–∞–Ω–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã

- [–ê–ª–≥–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—á–µ—Ç–æ–≤](algorithms.md) - –¥–µ—Ç–∞–ª–∏ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
- [–°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö](database-structure.md) - —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
- [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å–∏—Å—Ç–µ–º—ã](../ARCHITECTURE.md) - –æ–±—â–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
- [–†–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º](../guides/troubleshooting.md) - –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –ø—Ä–æ–±–ª–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
- [–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã](../guides/configuration.md) - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
